---
## Front matter
title: "ОТЧЕТ ПО ЛАБОРАТОРНОЙ РАБОТЕ № 14"
subtitle: " Именованные каналы"
author: "Коняева Марина Александровна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Приобретение практических навыков работы с именованными каналами.

# Теоретическое введение

Одним из видов взаимодействия между процессами в операционных системах является обмен сообщениями. Под сообщением понимается последовательность байтов,
передаваемая от одного процесса другому.
В операционных системах типа UNIX есть 3 вида межпроцессорных взаимодействий:
общеюниксные (именованные каналы, сигналы), System V Interface Definition (SVID —
разделяемая память, очередь сообщений, семафоры) и BSD (сокеты).
Для передачи данных между неродственными процессами можно использовать механизм именованных каналов (named pipes). Данные передаются по принципу FIFO (First
In First Out) (первым записан — первым прочитан), поэтому они называются также FIFO
pipes или просто FIFO. Именованные каналы отличаются от неименованных наличием
идентификатора канала, который представлен как специальный файл (соответственно
имя именованного канала — это имя файла). Поскольку файл находится на локальной
файловой системе, данное IPC используется внутри одной системы.

# Выполнение лабораторной работы

1. Скрипт 1-4 (изображение 1.1-4)

![Скрипт 1](image/14.1.png){ #fig:001 width=100% }
*Изображение 1.1  Скрипт 1*

![Скрипт 2](image/14.2.png){ #fig:001 width=100% }
*Изображение 1.2  Скрипт 2*

![Скрипт 3](image/14.3.png){ #fig:001 width=100% }
*Изображение 1.3  Скрипт 3*

![Скрипт 4](image/14.4.png){ #fig:001 width=100% }
*Изображение 1.4  Скрипт 4*

2. Запустим в разных консолях (изображение 2.1)

![Скрипт 2](image/14.5.png){ #fig:001 width=100% }
*Изображение 2.1 Запустим в разных консолях*

# Выводы

В ходе данной лабораторной работы приобрели практических навыков работы с именованными каналами, а также ответили на контрольные вопросы.

# Контрольные вопросы

1.	Именованные каналы отличаются от неименованных наличием имени (странно, не правда ли?), то есть идентификатора канала, потенциально видимого всем процессам системы. Для идентификации именованного канала создается файл специального типа pipe.

2.	Для создания неименованного канала используется системный вызов pipe. Массив из двух целых чисел является выходным параметром этого системного вызова. Если вызов выполнился нормально, то массив содержит два файловых дескриптора: для чтения информации из канала и для записи в него соответственно.

3.	Чтобы создать именованный канал, используется команда: mkfifo <pipe-name>. Она создает файл именованного канала, который можно использовать даже в нескольких сеансах оболочки. Другой способ создать именованный канал FIFO - использовать следующую команду: mknod p <pipe-name>. Чтобы перенаправить стандартный вывод любой команды другому процессу, используйте символ >. Чтобы перенаправить стандартный ввод любой команды, используйте символ <.

4.	Для создания неименованного канала используется системный вызов pipe. Массив из двух целых чисел является выходным параметром этого системного вызова. Если вызов выполнился нормально, то массив содержит два файловых дескриптора: для чтения информации из канала и для записи в него соответственно.

5.	Использование пайпов для передачи данных внутри одного процесса -- дичайший оверкилл, хуже было бы разве что использовать сокеты. Для передачи данных из потока в поток используйте разделяемую структуру данных (например, std::queue), защищая её от одновременного доступа при помощи мьютекса (например, CRITICAL_SECTION, если хотите Windows-specific, или лучше std::mutex, если ваш компилятор поддерживает стандарт C++11).

6.	При чтении большего числа байтов, чем находится в канале или FIFO, возвращается доступное число байтов. Процесс, читающий из канала, должен соответствующим образом обработать ситуацию, когда прочитано меньше, чем заказано.

7.	При чтении большего числа байтов, чем находится в канале или FIFO, возвращается доступное число байтов. Процесс, читающий из канала, должен соответствующим образом обработать ситуацию, когда прочитано меньше, чем заказано. 3. Если канал пуст и ни один процесс не открыл его на запись, при чтении из канала будет получено 0 байтов. ... Это означает, что в случае, когда несколько процессов одновременно записывают в канал, порции данных от этих процессов не перемешиваются. 5. При записи большего числа байтов, чем это позволяет канал или FIFO, вызов write(2) блокируется до освобождения требуемого места. При этом атомарность операции не гарантируется.

8. Однако если два или более процесса записывают в канал данные одновременно, каждый процесс за один раз может записать максимум PIPE BUF байтов данных. Предположим, процесс (назовем его А) пытается записать X байтов данных в канал, в котором имеется место для Y байтов данных. Если X больше, чем Y, только первые Y байтов данных записываются в канал, и процесс блокируется. Запускается другой процесс (например. В); в это время в канале появляется свободное пространство (благодаря третьему процессу, считывающему данные из канала). Процесс В записывает данные в канал.

9. Функция — это самостоятельная единица программы, которая спроектирована для реализации конкретной подзадачи. Функция является подпрограммой, которая может содержаться в основной программе, а может быть создана отдельно (в библиотеке). Каждая функция выполняет в программе определенные действия. ... Если функция не возвращает значения, то тип возвращаемого значения для нее указывается как void. При этом операция return может быть опущена.

10. Функция strerror формирует описание ошибки по коду ошибки указанному в аргументе errcode и возвращает указатель на строку, содержащую сформированное описание ошибки.